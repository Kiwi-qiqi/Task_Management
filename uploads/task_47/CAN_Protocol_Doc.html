<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CAN/CANFD ISO-TP 协议详解</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #e74c3c;
            --light: #ecf0f1;
            --dark: #2c3e50;
            --success: #2ecc71;
            --warning: #f39c12;
            --info: #3498db;
            --code-bg: #1e1e1e;
            --border-radius: 8px;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            padding: 2rem;
            border-radius: var(--border-radius);
            margin-bottom: 2rem;
            box-shadow: var(--shadow);
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        header::before {
            content: "";
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            z-index: 1;
        }
        
        header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            position: relative;
            z-index: 2;
        }
        
        header p {
            font-size: 1.2rem;
            opacity: 0.9;
            position: relative;
            z-index: 2;
        }
        
        .toc {
            background: white;
            border-radius: var(--border-radius);
            padding: 1.5rem;
            margin-bottom: 2rem;
            box-shadow: var(--shadow);
        }
        
        .toc h2 {
            color: var(--primary);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .toc h2 i {
            color: var(--secondary);
        }
        
        .toc ol {
            list-style-type: none;
            counter-reset: toc-counter;
        }
        
        .toc li {
            counter-increment: toc-counter;
            margin-bottom: 0.5rem;
            position: relative;
            padding-left: 2rem;
        }
        
        .toc li::before {
            content: counter(toc-counter);
            background: var(--secondary);
            color: white;
            width: 1.5rem;
            height: 1.5rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: absolute;
            left: 0;
            top: 0;
            font-size: 0.8rem;
            font-weight: bold;
        }
        
        .toc a {
            text-decoration: none;
            color: var(--dark);
            transition: var(--transition);
            display: block;
            padding: 0.3rem 0;
        }
        
        .toc a:hover {
            color: var(--secondary);
            transform: translateX(5px);
        }
        
        .content {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 2rem;
        }
        
        .main-content {
            background: white;
            border-radius: var(--border-radius);
            padding: 2rem;
            box-shadow: var(--shadow);
        }
        
        .section {
            margin-bottom: 3rem;
            scroll-margin-top: 100px;
        }
        
        .section h2 {
            color: var(--primary);
            border-left: 5px solid var(--secondary);
            padding-left: 1rem;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .section h3 {
            color: var(--secondary);
            margin: 1.5rem 0 1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .section h3 i {
            color: var(--accent);
        }
        
        .section p {
            margin-bottom: 1rem;
        }
        
        .section ul, .section ol {
            margin-left: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        .section li {
            margin-bottom: 0.5rem;
        }
        
        .frame-type {
            background: var(--light);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border-left: 4px solid var(--info);
        }
        
        .frame-type h4 {
            color: var(--primary);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .frame-type h4 i {
            color: var(--info);
        }
        
        .frame-format {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: var(--border-radius);
            padding: 1rem;
            margin: 1rem 0;
            font-family: monospace;
            white-space: pre;
            overflow-x: auto;
        }
        
        code {
            background: var(--code-bg);
            color: #d4d4d4;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: 'Consolas', monospace;
            font-size: 0.9rem;
        }
        
        pre {
            background: var(--code-bg);
            color: #d4d4d4;
            padding: 1rem;
            border-radius: var(--border-radius);
            margin: 1rem 0;
            overflow-x: auto;
            font-family: 'Consolas', monospace;
            line-height: 1.5;
        }
        
        .code-example {
            position: relative;
        }
        
        .code-example::before {
            content: "示例";
            position: absolute;
            top: 0;
            right: 0;
            background: var(--accent);
            color: white;
            padding: 0.3rem 0.8rem;
            border-radius: 0 var(--border-radius) 0 var(--border-radius);
            font-size: 0.8rem;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: 0 0 0 1px #e0e0e0;
        }
        
        th {
            background: var(--primary);
            color: white;
            padding: 1rem;
            text-align: left;
        }
        
        td {
            padding: 1rem;
            border-bottom: 1px solid #e0e0e0;
        }
        
        tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .flow-diagram {
            background: #f0f7ff;
            border-radius: var(--border-radius);
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid var(--info);
        }
        
        .flow-diagram pre {
            background: transparent;
            color: #333;
            padding: 0;
            margin: 0;
            white-space: pre-wrap;
        }
        
        .note {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 1rem;
            margin: 1.5rem 0;
            border-radius: 0 var(--border-radius) var(--border-radius) 0;
        }
        
        .warning {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 1rem;
            margin: 1.5rem 0;
            border-radius: 0 var(--border-radius) var(--border-radius) 0;
        }
        
        .success {
            background: #d1edff;
            border-left: 4px solid var(--success);
            padding: 1rem;
            margin: 1.5rem 0;
            border-radius: 0 var(--border-radius) var(--border-radius) 0;
        }
        
        .sidebar {
            background: white;
            border-radius: var(--border-radius);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            height: fit-content;
            position: sticky;
            top: 20px;
        }
        
        .sidebar h3 {
            color: var(--primary);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .sidebar h3 i {
            color: var(--accent);
        }
        
        .sidebar ul {
            list-style-type: none;
        }
        
        .sidebar li {
            margin-bottom: 0.8rem;
            padding-left: 1.5rem;
            position: relative;
        }
        
        .sidebar li::before {
            content: "•";
            color: var(--secondary);
            position: absolute;
            left: 0;
        }
        
        .sidebar a {
            text-decoration: none;
            color: var(--dark);
            transition: var(--transition);
            display: block;
        }
        
        .sidebar a:hover {
            color: var(--secondary);
        }
        
        .appendix {
            background: white;
            border-radius: var(--border-radius);
            padding: 2rem;
            margin-top: 2rem;
            box-shadow: var(--shadow);
        }
        
        .appendix h2 {
            color: var(--primary);
            margin-bottom: 1.5rem;
            border-left: 5px solid var(--accent);
            padding-left: 1rem;
        }
        
        footer {
            text-align: center;
            padding: 2rem;
            margin-top: 3rem;
            color: var(--primary);
            opacity: 0.8;
        }
        
        @media (max-width: 768px) {
            .content {
                grid-template-columns: 1fr;
            }
            
            .sidebar {
                position: static;
                margin-top: 2rem;
            }
            
            header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-network-wired"></i> CAN/CANFD ISO-TP 协议详解</h1>
            <p>专业教学文档 - 深入理解车载网络数据传输协议</p>
        </header>
        
        <div class="toc">
            <h2><i class="fas fa-list-ol"></i> 目录</h2>
            <ol>
                <li><a href="#overview">协议概述</a></li>
                <li><a href="#frame-types">帧类型详解</a></li>
                <li><a href="#transmission-flow">传输流程</a></li>
                <li><a href="#flow-control">流控机制</a></li>
                <li><a href="#implementation">实现细节</a></li>
                <li><a href="#examples">使用示例</a></li>
                <li><a href="#faq">常见问题</a></li>
            </ol>
        </div>
        
        <div class="content">
            <div class="main-content">
                <section id="overview" class="section">
                    <h2><i class="fas fa-info-circle"></i> 协议概述</h2>
                    
                    <h3><i class="fas fa-question"></i> 什么是 ISO-TP？</h3>
                    <p>ISO-TP (ISO 15765-2) 是一种传输协议，用于在 CAN 总线上传输大于单个 CAN 帧容量的数据。</p>
                    
                    <h3><i class="fas fa-exclamation-circle"></i> 为什么需要 ISO-TP？</h3>
                    <ul>
                        <li><strong>CAN 限制</strong>：传统 CAN 帧最多只能传输 8 字节数据</li>
                        <li><strong>CANFD 限制</strong>：CANFD 帧最多可传输 64 字节数据</li>
                        <li><strong>实际需求</strong>：汽车诊断（UDS）等应用经常需要传输数百甚至数千字节的数据</li>
                    </ul>
                    
                    <div class="note">
                        <p><strong>ISO-TP 的作用</strong>：将大数据分割成多个小帧传输，并在接收端重新组装。</p>
                    </div>
                </section>
                
                <section id="frame-types" class="section">
                    <h2><i class="fas fa-layer-group"></i> 帧类型详解</h2>
                    
                    <div class="frame-type">
                        <h4><i class="fas fa-file"></i> 1. 单帧 (Single Frame - SF)</h4>
                        <p><strong>用途</strong>：当数据长度不超过单帧最大容量时使用</p>
                        
                        <p><strong>帧格式</strong>：</p>
                        <div class="frame-format">
CAN (8字节):
┌────┬────┬────┬────┬────┬────┬────┬────┐
│ PCI│Data│Data│Data│Data│Data│Data│Data│
└────┴────┴────┴────┴────┴────┴────┴────┘
  1B   最多 7 字节数据

CANFD (64字节):
┌────┬────┬────┬────┬─────────────────────┐
│PCI │PCI │Data│Data│     Data ...        │
│ H  │ L  │    │    │                     │
└────┴────┴────┴────┴─────────────────────┘
  2B       最多 62 字节数据
                        </div>
                        
                        <p><strong>PCI 字段解析</strong>：</p>
                        <ul>
                            <li><strong>CAN</strong>: <code>0x0L</code>，其中 L = 数据长度 (0-7)</li>
                            <li><strong>CANFD</strong>: <code>0x00 LL</code>，其中 LL = 数据长度 (0-62)</li>
                        </ul>
                        
                        <p><strong>示例</strong>：</p>
                        <div class="code-example">
                            <pre><code># 发送 3 字节数据: [0x10, 0x01, 0x02]
# CAN 单帧: [0x03, 0x10, 0x01, 0x02]
#            ^^^^  ^^^^^^^^^^^^^^^^^^^^
#            PCI   数据</code></pre>
                        </div>
                    </div>
                    
                    <div class="frame-type">
                        <h4><i class="fas fa-file-alt"></i> 2. 首帧 (First Frame - FF)</h4>
                        <p><strong>用途</strong>：多帧传输的第一帧，携带总数据长度信息</p>
                        
                        <p><strong>帧格式</strong>：</p>
                        <div class="frame-format">
┌────┬────┬────┬────┬─────────────────────┐
│PCI │PCI │Data│Data│     Data ...        │
│ H  │ L  │    │    │                     │
└────┴────┴────┴────┴─────────────────────┘
  2B       数据（填满剩余空间）

PCI_H: 0x1L  (L = 总长度高4位)
PCI_L: 0xLL  (LL = 总长度低8位)
总长度 = (L << 8) | LL (12位，最大4095字节)
                        </div>
                        
                        <p><strong>示例</strong>：</p>
                        <div class="code-example">
                            <pre><code># 发送 100 字节数据
# 首帧 PCI: [0x10, 0x64]
#            ^^^^  ^^^^
#             |     |
#       首帧标识   总长度=0x0064=100</code></pre>
                        </div>
                    </div>
                    
                    <div class="frame-type">
                        <h4><i class="fas fa-file-contract"></i> 3. 连续帧 (Consecutive Frame - CF)</h4>
                        <p><strong>用途</strong>：多帧传输的后续帧，携带剩余数据</p>
                        
                        <p><strong>帧格式</strong>：</p>
                        <div class="frame-format">
┌────┬────┬────┬─────────────────────────┐
│PCI │Data│Data│     Data ...            │
└────┴────┴────┴─────────────────────────┘
  1B   数据（填满剩余空间）

PCI: 0x2S  (S = 序列号 0-15，循环)
                        </div>
                        
                        <p><strong>序列号规则</strong>：</p>
                        <ul>
                            <li>从 1 开始（首帧后的第一个连续帧）</li>
                            <li>0-15 循环（超过 15 后回到 0）</li>
                            <li>接收端必须验证序列号连续性</li>
                        </ul>
                        
                        <p><strong>示例</strong>：</p>
                        <div class="code-example">
                            <pre><code># 连续帧序列
CF1: [0x21, data...]  # SN=1
CF2: [0x22, data...]  # SN=2
...
CF15: [0x2F, data...] # SN=15
CF16: [0x20, data...] # SN=0 (循环)</code></pre>
                        </div>
                    </div>
                    
                    <div class="frame-type">
                        <h4><i class="fas fa-tachometer-alt"></i> 4. 流控帧 (Flow Control Frame - FC)</h4>
                        <p><strong>用途</strong>：接收端发送给发送端，控制数据流速</p>
                        
                        <p><strong>帧格式</strong>：</p>
                        <div class="frame-format">
┌────┬────┬─────┐
│PCI │ BS │STmin│
└────┴────┴─────┘
  1B   1B   1B

PCI: 0x3F  (F = Flow Status)
BS:  Block Size (块大小)
STmin: Separation Time minimum (最小间隔时间)
                        </div>
                        
                        <p><strong>Flow Status (FS)</strong>：</p>
                        <ul>
                            <li><code>0x0</code> - <strong>CTS</strong> (Continue To Send)：继续发送</li>
                            <li><code>0x1</code> - <strong>WAIT</strong>：等待（稍后会再发流控帧）</li>
                            <li><code>0x2</code> - <strong>OVERFLOW</strong>：缓冲区溢出，终止传输</li>
                        </ul>
                        
                        <p><strong>Block Size (BS)</strong>：</p>
                        <ul>
                            <li><code>0x00</code>：不限制，一次性发送所有连续帧</li>
                            <li><code>0x01-0xFF</code>：每发送 BS 个连续帧后，必须等待新的流控帧</li>
                        </ul>
                        
                        <p><strong>STmin (Separation Time Minimum)</strong>：</p>
                        <ul>
                            <li><code>0x00-0x7F</code>：0-127 毫秒</li>
                            <li><code>0xF1-0xF9</code>：100-900 微秒 (0.1-0.9ms)</li>
                            <li>其他值：保留</li>
                        </ul>
                        
                        <p><strong>示例</strong>：</p>
                        <div class="code-example">
                            <pre><code># 流控帧: [0x30, 0x05, 0x0A]
#          ^^^^  ^^^^  ^^^^
#           |     |     |
#          CTS   BS=5  STmin=10ms
# 
# 含义：继续发送，每5帧等待一次流控，帧间隔>=10ms</code></pre>
                        </div>
                    </div>
                </section>
                
                <section id="transmission-flow" class="section">
                    <h2><i class="fas fa-exchange-alt"></i> 传输流程</h2>
                    
                    <h3><i class="fas fa-arrow-right"></i> 单帧传输流程</h3>
                    <div class="flow-diagram">
                        <pre>
发送端                    接收端
  │                         │
  │──── Single Frame ──────>│
  │                         │
  │                      [完成接收]
                        </pre>
                    </div>
                    
                    <div class="note">
                        <p><strong>特点</strong>：简单快速，无需流控，适合小数据量（CAN: ≤7字节, CANFD: ≤62字节）</p>
                    </div>
                    
                    <h3><i class="fas fa-arrows-alt-h"></i> 多帧传输流程（无块大小限制）</h3>
                    <div class="flow-diagram">
                        <pre>
发送端                    接收端
  │                         │
  │──── First Frame ───────>│
  │                         │
  │<─── Flow Control ───────│ (BS=0)
  │                         │
  │─ Consecutive Frame #1──>│
  │─ Consecutive Frame #2──>│
  │─ Consecutive Frame #3──>│
  │        ...              │
  │─ Consecutive Frame #N──>│
  │                         │
  │                      [完成接收]
                        </pre>
                    </div>
                    
                    <p><strong>流程说明</strong>：</p>
                    <ol>
                        <li>发送端发送首帧（包含总长度）</li>
                        <li>接收端返回流控帧（BS=0 表示不限制）</li>
                        <li>发送端连续发送所有连续帧</li>
                        <li>接收端验证序列号并组装数据</li>
                    </ol>
                    
                    <h3><i class="fas fa-arrows-alt-h"></i> 多帧传输流程（带块大小限制）</h3>
                    <div class="flow-diagram">
                        <pre>
发送端                    接收端
  │                         │
  │──── First Frame ───────>│
  │                         │
  │<─── Flow Control ───────│ (BS=5, STmin=10ms)
  │                         │
  │─ CF #1 ────> [等10ms]   │
  │─ CF #2 ────> [等10ms]   │
  │─ CF #3 ────> [等10ms]   │
  │─ CF #4 ────> [等10ms]   │
  │─ CF #5 ─────────────────>│
  │                         │
  │<─── Flow Control ───────│ (再次请求5帧)
  │                         │
  │─ CF #6 ────> [等10ms]   │
  │─ CF #7 ────> [等10ms]   │
  │        ...              │
                        </pre>
                    </div>
                    
                    <p><strong>流程说明</strong>：</p>
                    <ol>
                        <li>接收端设置 BS=5，表示每次最多接收 5 个连续帧</li>
                        <li>发送端每发送 5 帧后，必须等待新的流控帧</li>
                        <li>STmin=10ms 表示每帧之间至少间隔 10ms</li>
                        <li>这种机制防止接收端缓冲区溢出</li>
                    </ol>
                </section>
                
                <section id="flow-control" class="section">
                    <h2><i class="fas fa-sliders-h"></i> 流控机制</h2>
                    
                    <h3><i class="fas fa-question-circle"></i> 为什么需要流控？</h3>
                    <ol>
                        <li><strong>缓冲区管理</strong>：接收端可能处理速度较慢，需要控制发送速率</li>
                        <li><strong>总线负载</strong>：避免占用过多总线带宽</li>
                        <li><strong>实时性</strong>：允许高优先级消息插入</li>
                    </ol>
                    
                    <h3><i class="fas fa-cogs"></i> 流控策略</h3>
                    
                    <div class="success">
                        <h4><i class="fas fa-bolt"></i> 策略1：无限制发送 (BS=0)</h4>
                        <div class="code-example">
                            <pre><code>rx_adapter.block_size = 0
rx_adapter.st_min = 0</code></pre>
                        </div>
                        <p><strong>优点</strong>：传输速度最快</p>
                        <p><strong>缺点</strong>：可能导致缓冲区溢出</p>
                        <p><strong>适用</strong>：小数据量或接收端处理能力强</p>
                    </div>
                    
                    <div class="note">
                        <h4><i class="fas fa-tachometer-alt"></i> 策略2：固定块大小 (BS>0)</h4>
                        <div class="code-example">
                            <pre><code>rx_adapter.block_size = 8
rx_adapter.st_min = 5  # 5ms间隔</code></pre>
                        </div>
                        <p><strong>优点</strong>：可控的数据流，便于缓冲区管理</p>
                        <p><strong>缺点</strong>：增加传输延迟</p>
                        <p><strong>适用</strong>：大数据量或接收端资源受限</p>
                    </div>
                    
                    <div class="warning">
                        <h4><i class="fas fa-chart-line"></i> 策略3：动态调整</h4>
                        <div class="code-example">
                            <pre><code># 根据缓冲区使用情况动态调整
if buffer_usage < 50%:
    block_size = 0  # 不限制
elif buffer_usage < 80%:
    block_size = 10
else:
    block_size = 5  # 严格限制</code></pre>
                        </div>
                        <p><strong>优点</strong>：自适应，平衡效率和安全性</p>
                        <p><strong>缺点</strong>：实现复杂度较高</p>
                        <p><strong>适用</strong>：需要智能流量控制的场景</p>
                    </div>
                </section>
                
                <section id="implementation" class="section">
                    <h2><i class="fas fa-code"></i> 实现细节</h2>
                    
                    <h3><i class="fas fa-key"></i> PCI 编码规则</h3>
                    <div class="code-example">
                        <pre><code>def encode_pci(frame_type, length_or_sequence):
    """
    编码 PCI 字段
    
    单帧 (SF):   [0x0L]        - L=数据长度
    首帧 (FF):   [0x1H, 0xLL]  - H:L=总长度(12位)
    连续帧 (CF): [0x2S]        - S=序列号(0-15)
    流控帧 (FC): [0x3F]        - F=流状态(0-2)
    """
    if frame_type == SINGLE:
        return bytes([(0x0 << 4) | length_or_sequence])
    elif frame_type == FIRST:
        high = (0x1 << 4) | ((length_or_sequence >> 8) & 0x0F)
        low = length_or_sequence & 0xFF
        return bytes([high, low])
    elif frame_type == CONSECUTIVE:
        return bytes([(0x2 << 4) | (length_or_sequence & 0x0F)])
    elif frame_type == FLOW_CONTROL:
        return bytes([(0x3 << 4) | (length_or_sequence & 0x0F)])</code></pre>
                    </div>
                    
                    <h3><i class="fas fa-sort-numeric-down"></i> 序列号管理</h3>
                    <div class="code-example">
                        <pre><code># 发送端
self.next_sequence = 1  # 首个连续帧从1开始
for each_frame:
    pci = (0x2 << 4) | (self.next_sequence & 0x0F)
    self.next_sequence = (self.next_sequence + 1) % 16  # 0-15循环

# 接收端
def validate_sequence(received_sn):
    if received_sn != self.expected_sequence:
        raise SequenceError(f"期望{self.expected_sequence}, 实际{received_sn}")
    self.expected_sequence = (self.expected_sequence + 1) % 16</code></pre>
                    </div>
                    
                                        <h3><i class="fas fa-cut"></i> 数据分帧算法</h3>
                    <div class="code-example">
                        <pre><code>def split_data(data, frame_size):
    """
    将数据分割成多个帧
    
    首帧: [PCI(2B)] [Data(frame_size-2)]
    连续帧: [PCI(1B)] [Data(frame_size-1)]
    """
    frames = []
    
    # 首帧
    first_payload_size = frame_size - 2
    frames.append(create_first_frame(data, first_payload_size))
    
    # 连续帧
    remaining = data[first_payload_size:]
    while remaining:
        cf_payload_size = min(len(remaining), frame_size - 1)
        frames.append(create_consecutive_frame(remaining[:cf_payload_size]))
        remaining = remaining[cf_payload_size:]
    
    return frames</code></pre>
                    </div>
                </section>
                
                <section id="examples" class="section">
                    <h2><i class="fas fa-laptop-code"></i> 使用示例</h2>
                    
                    <h3><i class="fas fa-play-circle"></i> 示例1：简单发送接收</h3>
                    <div class="code-example">
                        <pre><code>from can_protocol_adapter import CAN_Protocol_Adapter

# 初始化适配器
tx = CAN_Protocol_Adapter(is_canfd=True)
rx = CAN_Protocol_Adapter(is_canfd=True)

# 发送数据
test_data = bytes(range(100))
frames = tx.send(test_data)

# 接收首帧
data, fc_frame = rx.receive(frames[0])

# 发送端处理流控
tx.receive(fc_frame)

# 发送连续帧
consecutive_frames = tx.send_consecutive_frames()
for cf in consecutive_frames:
    data, _ = rx.receive(cf)
    if data:
        print(f"接收完成: {len(data)} 字节")
        break</code></pre>
                    </div>
                    
                    <h3><i class="fas fa-tasks"></i> 示例2：带流控的发送</h3>
                    <div class="code-example">
                        <pre><code># 设置流控参数
rx.block_size = 10  # 每10帧等待一次流控
rx.st_min = 5       # 帧间隔5ms

# 分块发送
while True:
    max_frames = tx.block_size if tx.block_size > 0 else None
    frames = tx.send_consecutive_frames(max_frames)
    
    if not frames:
        break
    
    for frame in frames:
        # 这里应该加上STmin的延迟
        time.sleep(tx.st_min / 1000.0)
        
        data, fc = rx.receive(frame)
        
        if data:
            print("传输完成")
            break
        
        if fc:
            tx.receive(fc)  # 处理中间流控帧
            break</code></pre>
                    </div>
                    
                    <h3><i class="fas fa-exclamation-triangle"></i> 示例3：错误处理</h3>
                    <div class="code-example">
                        <pre><code>try:
    data, fc = rx.receive(frame)
except SequenceError as e:
    print(f"序列号错误: {e}")
    rx.reset()  # 重置接收状态
except FrameLengthError as e:
    print(f"帧长度错误: {e}")
except FlowControlError as e:
    print(f"流控错误: {e}")
    # 停止发送</code></pre>
                    </div>
                </section>
                
                <section id="faq" class="section">
                    <h2><i class="fas fa-question-circle"></i> 常见问题</h2>
                    
                    <div class="faq-item">
                        <h3><i class="fas fa-arrow-circle-right"></i> Q1: 为什么序列号是0-15循环？</h3>
                        <p><strong>A</strong>: 因为 PCI 只用 4 位来存储序列号，最多表示 16 个值（0-15）。对于超长数据传输，序列号会循环使用。</p>
                    </div>
                    
                    <div class="faq-item">
                        <h3><i class="fas fa-arrow-circle-right"></i> Q2: 如何选择合适的 Block Size？</h3>
                        <p><strong>A</strong>: 考虑以下因素：</p>
                        <ul>
                            <li><strong>接收缓冲区大小</strong>：BS 不应超过缓冲区容量</li>
                            <li><strong>处理速度</strong>：处理慢选小 BS</li>
                            <li><strong>传输效率</strong>：BS=0 效率最高但风险大</li>
                        </ul>
                        <p><strong>推荐值</strong>：</p>
                        <ul>
                            <li>高速场景：BS=0 或 BS=20-50</li>
                            <li>普通场景：BS=8-16</li>
                            <li>资源受限：BS=4-8</li>
                        </ul>
                    </div>
                    
                    <div class="faq-item">
                        <h3><i class="fas fa-arrow-circle-right"></i> Q3: STmin 应该设置多少？</h3>
                        <p><strong>A</strong>:</p>
                        <ul>
                            <li><strong>0ms</strong>：最快速度，无延迟</li>
                            <li><strong>5-10ms</strong>：通用推荐值</li>
                            <li><strong>20-50ms</strong>：低优先级传输</li>
                            <li><strong>>50ms</strong>：特殊需求（如总线负载高）</li>
                        </ul>
                    </div>
                    
                    <div class="faq-item">
                        <h3><i class="fas fa-arrow-circle-right"></i> Q4: 如何处理传输中断？</h3>
                        <p><strong>A</strong>:</p>
                        <div class="code-example">
                            <pre><code># 发送端
try:
    frames = tx.send_consecutive_frames()
except Exception:
    tx._reset_send_state()  # 清理发送状态

# 接收端
if timeout_occurred:
    rx.reset()  # 清理接收状态</code></pre>
                        </div>
                    </div>
                    
                    <div class="faq-item">
                        <h3><i class="fas fa-arrow-circle-right"></i> Q5: CAN 和 CANFD 的主要区别？</h3>
                        <p><strong>A</strong>:</p>
                        <table>
                            <thead>
                                <tr>
                                    <th>特性</th>
                                    <th>CAN</th>
                                    <th>CANFD</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>最大帧长</td>
                                    <td>8字节</td>
                                    <td>64字节</td>
                                </tr>
                                <tr>
                                    <td>单帧最大数据</td>
                                    <td>7字节</td>
                                    <td>62字节</td>
                                </tr>
                                <tr>
                                    <td>PCI长度</td>
                                    <td>1字节(SF) / 2字节(FF)</td>
                                    <td>统一2字节</td>
                                </tr>
                                <tr>
                                    <td>传输效率</td>
                                    <td>较低</td>
                                    <td>高</td>
                                </tr>
                                <tr>
                                    <td>兼容性</td>
                                    <td>广泛</td>
                                    <td>需要新硬件</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    
                    <div class="faq-item">
                        <h3><i class="fas fa-arrow-circle-right"></i> Q6: 如何优化传输性能？</h3>
                        <p><strong>A</strong>:</p>
                        <ol>
                            <li><strong>使用 CANFD</strong>：8倍数据容量提升</li>
                            <li><strong>BS=0</strong>：避免流控开销</li>
                            <li><strong>STmin=0</strong>：无帧间延迟</li>
                            <li><strong>预分配缓冲区</strong>：避免动态内存分配</li>
                            <li><strong>批量处理</strong>：减少函数调用开销</li>
                        </ol>
                        <p><strong>示例</strong>：</p>
                        <div class="code-example">
                            <pre><code># 高性能配置
rx.block_size = 0    # 不限制
rx.st_min = 0        # 无延迟
adapter = CAN_Protocol_Adapter(is_canfd=True)  # 使用CANFD</code></pre>
                        </div>
                    </div>
                    
                    <div class="faq-item">
                        <h3><i class="fas fa-arrow-circle-right"></i> Q7: 如何调试传输问题？</h3>
                        <p><strong>A</strong>: 使用日志系统：</p>
                        <div class="code-example">
                            <pre><code>import logging

# 启用详细日志
logging.basicConfig(level=logging.DEBUG)

# 查看帧内容
logger.debug(f"发送帧: {frame.hex()}")
logger.debug(f"PCI: {frame[0]:02x}, 数据: {frame[1:].hex()}")

# 检查状态
logger.debug(f"序列号: 期望={rx.expected_sequence}, 实际={received_sn}")
logger.debug(f"数据进度: {len(rx.received_data)}/{rx.total_length}")</code></pre>
                        </div>
                    </div>
                    
                    <div class="faq-item">
                        <h3><i class="fas fa-arrow-circle-right"></i> Q8: 多个设备同时通信怎么办？</h3>
                        <p><strong>A</strong>: 使用 CAN ID 区分：</p>
                        <div class="code-example">
                            <pre><code># 不同的 CAN ID 对应不同的通信通道
ECU1_TX = 0x700  # ECU1 发送
ECU1_RX = 0x708  # ECU1 接收

ECU2_TX = 0x710  # ECU2 发送
ECU2_RX = 0x718  # ECU2 接收

# 根据 CAN ID 路由到对应的适配器
if can_id == ECU1_RX:
    ecu1_adapter.receive(data)
elif can_id == ECU2_RX:
    ecu2_adapter.receive(data)</code></pre>
                        </div>
                    </div>
                </section>
            </div>
            
            <div class="sidebar">
                <h3><i class="fas fa-lightbulb"></i> 快速导航</h3>
                <ul>
                    <li><a href="#overview">协议概述</a></li>
                    <li><a href="#frame-types">帧类型详解</a></li>
                    <li><a href="#transmission-flow">传输流程</a></li>
                    <li><a href="#flow-control">流控机制</a></li>
                    <li><a href="#implementation">实现细节</a></li>
                    <li><a href="#examples">使用示例</a></li>
                    <li><a href="#faq">常见问题</a></li>
                </ul>
                
                <h3><i class="fas fa-bookmark"></i> 关键要点</h3>
                <ul>
                    <li>ISO-TP 用于大数据传输</li>
                    <li>支持单帧和多帧传输</li>
                    <li>流控机制防止溢出</li>
                    <li>序列号0-15循环</li>
                    <li>CANFD效率更高</li>
                </ul>
                
                <h3><i class="fas fa-cogs"></i> 性能优化</h3>
                <ul>
                    <li>使用 CANFD 提升效率</li>
                    <li>合理设置 BS 和 STmin</li>
                    <li>预分配缓冲区</li>
                    <li>批量处理减少开销</li>
                </ul>
            </div>
        </div>
        
        <div class="appendix">
            <h2><i class="fas fa-book"></i> 附录</h2>
            
            <h3><i class="fas fa-table"></i> A. PCI 字段速查表</h3>
            <table>
                <thead>
                    <tr>
                        <th>帧类型</th>
                        <th>PCI 格式</th>
                        <th>示例</th>
                        <th>说明</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>单帧</td>
                        <td>0x0L</td>
                        <td>0x03</td>
                        <td>L=3字节数据</td>
                    </tr>
                    <tr>
                        <td>首帧</td>
                        <td>0x1H LL</td>
                        <td>0x10 64</td>
                        <td>总长0x064=100字节</td>
                    </tr>
                    <tr>
                        <td>连续帧</td>
                        <td>0x2S</td>
                        <td>0x21</td>
                        <td>S=1序列号</td>
                    </tr>
                    <tr>
                        <td>流控帧</td>
                        <td>0x3F</td>
                        <td>0x30</td>
                        <td>F=0 CTS</td>
                    </tr>
                </tbody>
            </table>
            
            <h3><i class="fas fa-bug"></i> B. 错误码对照表</h3>
            <table>
                <thead>
                    <tr>
                        <th>错误类型</th>
                        <th>错误码</th>
                        <th>描述</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>SequenceError</td>
                        <td>SEQ_01</td>
                        <td>序列号不连续</td>
                    </tr>
                    <tr>
                        <td>FrameLengthError</td>
                        <td>LEN_01</td>
                        <td>帧长度不足</td>
                    </tr>
                    <tr>
                        <td>FlowControlError</td>
                        <td>FC_01</td>
                        <td>缓冲区溢出</td>
                    </tr>
                    <tr>
                        <td>TimeoutError</td>
                        <td>TO_01</td>
                        <td>接收超时</td>
                    </tr>
                    <tr>
                        <td>ProtocolError</td>
                        <td>PROTO_01</td>
                        <td>协议格式错误</td>
                    </tr>
                </tbody>
            </table>
            
            <h3><i class="fas fa-tachometer-alt"></i> C. 性能调优参数</h3>
            <table>
                <thead>
                    <tr>
                        <th>参数</th>
                        <th>默认值</th>
                        <th>范围</th>
                        <th>建议</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>block_size</td>
                        <td>0</td>
                        <td>0-255</td>
                        <td>0或8-16</td>
                    </tr>
                    <tr>
                        <td>st_min</td>
                        <td>0</td>
                        <td>0-127ms</td>
                        <td>0-10ms</td>
                    </tr>
                    <tr>
                        <td>buffer_size</td>
                        <td>4096</td>
                        <td>64-8192</td>
                        <td>根据需求</td>
                    </tr>
                    <tr>
                        <td>timeout</td>
                        <td>1000ms</td>
                        <td>100-5000ms</td>
                        <td>1000-2000ms</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <footer>
            <p><i class="fas fa-history"></i> 版本历史: v1.0 (2025-10-15) - 初始版本</p>
            <p><i class="fas fa-sync-alt"></i> 本文档持续更新中，最后更新日期: 2025-10-15</p>
        </footer>
    </div>

    <script>
        // 平滑滚动
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // 高亮当前章节
        const sections = document.querySelectorAll('.section');
        const navLinks = document.querySelectorAll('.sidebar a, .toc a');
        
        window.addEventListener('scroll', () => {
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if (scrollY >= (sectionTop - 100)) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                }
            });
        });

        // 代码复制功能
        document.querySelectorAll('.code-example').forEach(example => {
            const copyButton = document.createElement('button');
            copyButton.innerHTML = '<i class="fas fa-copy"></i>';
            copyButton.className = 'copy-btn';
            copyButton.style.cssText = `
                position: absolute;
                top: 5px;
                right: 5px;
                background: rgba(255,255,255,0.2);
                border: none;
                color: white;
                padding: 5px;
                border-radius: 3px;
                cursor: pointer;
                font-size: 12px;
            `;
            
            copyButton.addEventListener('click', () => {
                const code = example.querySelector('code').innerText;
                navigator.clipboard.writeText(code).then(() => {
                    copyButton.innerHTML = '<i class="fas fa-check"></i>';
                    setTimeout(() => {
                        copyButton.innerHTML = '<i class="fas fa-copy"></i>';
                    }, 2000);
                });
            });
            
            example.style.position = 'relative';
            example.appendChild(copyButton);
        });
    </script>
</body>
</html>