<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FirmwareChunker 技术文档</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f7fa;
        }
        .container {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 30px;
        }
        h1, h2, h3 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        h1 {
            text-align: center;
            color: #1a252f;
        }
        h2 {
            margin-top: 30px;
        }
        .section {
            margin-bottom: 40px;
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }
        .method, .function {
            margin-bottom: 25px;
            padding: 15px;
            background-color: #ffffff;
            border-radius: 5px;
            border: 1px solid #e0e0e0;
        }
        .method h3, .function h3 {
            margin-top: 0;
            color: #2980b9;
        }
        .signature {
            background-color: #f1f8ff;
            padding: 10px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            margin-bottom: 15px;
            overflow-x: auto;
        }
        .return-type {
            font-weight: bold;
            color: #27ae60;
        }
        .param {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
        }
        .param-name {
            font-weight: bold;
            min-width: 150px;
            font-family: 'Courier New', monospace;
            color: #e74c3c;
        }
        .param-type {
            font-family: 'Courier New', monospace;
            color: #8e44ad;
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
        }
        .required::after {
            content: "*";
            color: #e74c3c;
            font-weight: bold;
            margin-left: 3px;
        }
        .optional {
            color: #7f8c8d;
        }
        .example {
            background-color: #f0f8ff;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        .code {
            background-color: #f8f8f8;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
        .note {
            background-color: #fff9c4;
            border-left: 4px solid #f9a825;
            padding: 10px 15px;
            margin: 15px 0;
            border-radius: 3px;
        }
        .warning {
            background-color: #ffebee;
            border-left: 4px solid #f44336;
            padding: 10px 15px;
            margin: 15px 0;
            border-radius: 3px;
        }
        .attr-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        .attr-table th, .attr-table td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        .attr-table th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        .attr-table tr:last-child td {
            border-bottom: none;
        }
        .toc {
            background-color: #f0f7ff;
            border: 1px solid #b8daff;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 25px;
        }
        .toc ul {
            padding-left: 20px;
            margin-top: 10px;
        }
        .toc a {
            text-decoration: none;
            color: #0066cc;
        }
        .toc a:hover {
            text-decoration: underline;
        }
        footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            color: #777;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>FirmwareChunker 技术文档</h1>
        
        <div class="toc">
            <h3>目录</h3>
            <ul>
                <li><a href="#overview">模块概述</a></li>
                <li><a href="class">FirmwareChunker 类</a></li>
                <li><a href="#methods">核心方法</a></li>
                <li><a href="#utils">辅助函数</a></li>
                <li><a href="#example">使用示例</a></li>
                <li><a href="#performance">性能特性</a></li>
            </ul>
        </div>

        <div class="section" id="overview">
            <h2>模块概述</h2>
            <p>FirmwareChunker 是一个高性能的固件分块处理模块，专为大型固件文件设计。它支持将固件数据分割成多个数据块，每个块包含序列号和数据内容，适用于固件刷写场景。</p>
            
            <div class="note">
                <strong>核心特性：</strong>
                <ul>
                    <li>使用内存视图避免数据复制</li>
                    <li>支持生成器模式减少内存占用</li>
                    <li>批量操作优化处理速度</li>
                    <li>高效的数据结构（array）减少内存使用</li>
                </ul>
            </div>
        </div>

        <div class="section" id="class">
            <h2>FirmwareChunker 类</h2>
            
            <h3>初始化方法</h3>
            <div class="method">
                <h3>__init__</h3>
                <div class="signature">
                    def __init__(self, 
                              flash_data: Union[List[int], bytes, bytearray, array], 
                              block_max_bytes: int = 4095,
                              logger: Optional[logging.Logger] = None)
                </div>
                <p>初始化固件分块器实例</p>
                
                <h4>参数：</h4>
                <div class="param">
                    <span class="param-name required">flash_data</span>
                    <span class="param-type">Union[List[int], bytes, bytearray, array]</span>
                    <span>固件数据源，支持多种格式</span>
                </div>
                <div class="param">
                    <span class="param-name optional">block_max_bytes</span>
                    <span class="param-type">int</span>
                    <span>每个块的最大字节数（默认：4095）</span>
                </div>
                <div class="param">
                    <span class="param-name optional">logger</span>
                    <span class="param-type">Optional[logging.Logger]</span>
                    <span>日志记录器（可选，自动创建默认日志器）</span>
                </div>
                
                <h4>返回值：</h4>
                <p>初始化固件分块器实例</p>
                
                <div class="warning">
                    <strong>异常：</strong>
                    <ul>
                        <li><code>ValueError</code> - 当 block_max_bytes ≤ HEADER_BYTES (1) 时</li>
                        <li><code>TypeError</code> - 当 flash_data 类型不支持时</li>
                    </ul>
                </div>
            </div>
            
            <h3>类属性</h3>
            <table class="attr-table">
                <tr>
                    <th>属性名</th>
                    <th>类型</th>
                    <th>描述</th>
                </tr>
                <tr>
                    <td>flash_data</td>
                    <td>array</td>
                    <td>固件数据数组（使用array类型优化内存）</td>
                </tr>
                <tr>
                    <td>block_max_bytes</td>
                    <td>int</td>
                    <td>每个块的最大字节数</td>
                </tr>
                <tr>
                    <td>logger</td>
                    <td>logging.Logger</td>
                    <td>日志记录器实例</td>
                </tr>
                <tr>
                    <td>HEADER_BYTES</td>
                    <td>int</td>
                    <td>类常量：每个块的头部字节数（1）</td>
                </tr>
                <tr>
                    <td>DEFAULT_BLOCK_MAX_BYTES</td>
                    <td>int</td>
                    <td>类常量：默认块最大字节数（4095）</td>
                </tr>
            </table>
        </div>

        <div class="section" id="methods">
            <h2>核心方法</h2>
            
            <h3>separate_data_to_blocks</h3>
            <div class="method">
                <h3>separate_data_to_blocks</h3>
                <div class="signature">
                    def separate_data_to_blocks(self) -> Dict[int, bytes]
                </div>
                <p>将固件数据分割成多个完整的数据块</p>
                
                <h4>返回值：</h4>
                <p><span class="return-type">Dict[int, bytes]</span> - 块序列号到块数据的映射</p>
                
                <div class="example">
                    <strong>示例：</strong><br>
                    blocks = chunker.separate_data_to_blocks()<br>
                    for block_num, block_data in blocks.items():<br>
                    &nbsp;&nbsp;print(f"Block {block_num}: {len(block_data)} bytes")
                </div>
            </div>
            
            <h3>iter_blocks</h3>
            <div class="method">
                <h3>iter_blocks</h3>
                <div class="signature">
                    def iter_blocks(self) -> Generator[List[int], None, None]
                </div>
                <p>生成器模式，逐个生成数据块（推荐用于大文件）</p>
                
                <h4>返回值：</h4>
                <p><span class="return-type">Generator[List[int], None, None]</span> - 生成器，每个元素是一个块（包含序列号和数据）</p>
                
                <div class="example">
                    <strong>示例：</strong><br>
                    for block_num, block in enumerate(chunker.iter_blocks(), 1):<br>
                    &nbsp;&nbsp;process_block(block_num, block)
                </div>
            </div>
            
            <h3>iter_blocks_fast</h3>
            <div class="method">
                <h3>iter_blocks_fast</h3>
                <div class="signature">
                    def iter_blocks_fast(self) -> Iterator[tuple]
                </div>
                <p>快速迭代模式：仅返回序列号和位置信息，不复制数据</p>
                
                <h4>返回值：</h4>
                <p><span class="return-type">Iterator[tuple]</span> - 返回(block_number, start_index, end_index)元组</p>
                
                <div class="example">
                    <strong>示例：</strong><br>
                    for block_num, start, end in chunker.iter_blocks_fast():<br>
                    &nbsp;&nbsp;raw_data = chunker.flash_data[start:end]<br>
                    &nbsp;&nbsp;file.write(bytes([block_num]) + raw_data)
                </div>
            </div>
            
            <h3>get_block_info</h3>
            <div class="method">
                <h3>get_block_info</h3>
                <div class="signature">
                    def get_block_info(self) -> Dict[str, Union[int, float]]
                </div>
                <p>获取块统计信息</p>
                
                <h4>返回值：</h4>
                <p><span class="return-type">Dict[str, Union[int, float]]</span> - 包含块统计信息的字典</p>
                
                <h4>返回字段：</h4>
                <table class="attr-table">
                    <tr>
                        <th>字段</th>
                        <th>类型</th>
                        <th>描述</th>
                    </tr>
                    <tr>
                        <td>total_data_bytes</td>
                        <td>int</td>
                        <td>固件总数据大小（字节）</td>
                    </tr>
                    <tr>
                        <td>max_data_per_block</td>
                        <td>int</td>
                        <td>每块最大数据字节数</td>
                    </tr>
                    <tr>
                        <td>block_count</td>
                        <td>int</td>
                        <td>总块数</td>
                    </tr>
                    <tr>
                        <td>last_block_bytes</td>
                        <td>int</td>
                        <td>最后一个块的数据字节数</td>
                    </tr>
                    <tr>
                        <td>overhead_ratio</td>
                        <td>float</td>
                        <td>头部开销比率百分比</td>
                    </tr>
                </table>
            </div>
            
            <h3>get_block_by_index</h3>
            <div class="method">
                <h3>get_block_by_index</h3>
                <div class="signature">
                    def get_block_by_index(self, block_num: int) -> bytes
                </div>
                <p>通过序列号直接获取指定数据块（随机访问）</p>
                
                <h4>参数：</h4>
                <div class="param">
                    <span class="param-name required">block_num</span>
                    <span class="param-type">int</span>
                    <span>块序列号（从1开始）</span>
                </div>
                
                <h4>返回值：</h4>
                <p><span class="return-type">bytes</span> - 包含序列号和数据的块</p>
                
                <div class="warning">
                    <strong>异常：</strong>
                    <ul>
                        <li><code>ValueError</code> - 当块号超出范围时</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="section" id="utils">
            <h2>辅助函数</h2>
            
            <h3>format_hex_data</h3>
            <div class="function">
                <h3>format_hex_data</h3>
                <div class="signature">
                    def format_hex_data(data: Union[List[int], bytes, bytearray], 
                                      bytes_per_line: int = 16,
                                      max_lines: Optional[int] = None) -> str
                </div>
                <p>格式化十六进制数据显示（优化版）</p>
                
                <h4>参数：</h4>
                <div class="param">
                    <span class="param-name required">data</span>
                    <span class="param-type">Union[List[int], bytes, bytearray]</span>
                    <span>要格式化的数据列表或字节字符串</span>
                </div>
                <div class="param">
                    <span class="param-name optional">bytes_per_line</span>
                    <span class="param-type">int</span>
                    <span>每行显示的字节数（默认：16）</span>
                </div>
                <div class="param">
                    <span class="param-name optional">max_lines</span>
                    <span class="param-type">Optional[int]</span>
                    <span>最大显示行数（None表示全部）</span>
                </div>
                
                <h4>返回值：</h4>
                <p><span class="return-type">str</span> - 格式化的十六进制字符串</p>
                
                <div class="example">
                    <strong>示例：</strong><br>
                    hex_str = format_hex_data(data, bytes_per_line=8, max_lines=5)<br>
                    print(hex_str)
                </div>
            </div>
            
            <h3>setup_test_logger</h3>
            <div class="function">
                <h3>setup_test_logger</h3>
                <div class="signature">
                    def setup_test_logger() -> logging.Logger
                </div>
                <p>设置测试函数的日志记录器</p>
                
                <h4>返回值：</h4>
                <p><span class="return-type">logging.Logger</span> - 配置好的测试日志记录器</p>
                
                <div class="note">
                    <strong>功能：</strong>创建带有文件和控制台处理器的日志记录器
                </div>
            </div>
        </div>

        <div class="section" id="example">
            <h2>使用示例</h2>
            
            <h3>基本分块</h3>
            <div class="code">
                <pre>from firmware_chunker import FirmwareChunker

# 准备固件数据
firmware_data = bytes(range(256))  # 示例固件数据

# 创建分块器
chunker = FirmwareChunker(firmware_data, block_max_bytes=100)

# 获取块统计信息
info = chunker.get_block_info()
print(f"总块数: {info['block_count']}")

# 分离所有块
blocks = chunker.separate_data_to_blocks()
print(f"第1块长度: {len(blocks[1])} 字节")

# 使用生成器处理大文件
for block in chunker.iter_blocks():
    block_num = block[0]
    block_data = block[1:]
    # 处理每个块...</pre>
            </div>
            
            <h3>与HexParser集成</h3>
            <div class="code">
                <pre>from firmware_chunker import FirmwareChunker
from hex_file_parser import HexParser  # 假设的模块

# 解析HEX文件
hex_parser = HexParser("firmware.hex")

# 为每个Flash区域创建分块器
for region_id, flash_info in hex_parser.flash_info.items():
    chunker = FirmwareChunker(flash_info['Data'], block_max_bytes=4096)
    
    # 获取块信息
    block_info = chunker.get_block_info()
    
    # 使用快速迭代直接写入文件
    with open(f"firmware_region_{region_id}.bin", "wb") as f:
        for block_num, start, end in chunker.iter_blocks_fast():
            block_data = chunker.flash_data[start:end]
            f.write(bytes([block_num % 256] + list(block_data)))</pre>
            </div>
        </div>

        <div class="section" id="performance">
            <h2>性能特性</h2>
            
            <h3>内存优化</h3>
            <ul>
                <li>使用 <code>array('B')</code> 存储固件数据，比列表减少约50%内存占用</li>
                <li>生成器模式 (<code>iter_blocks</code>) 避免一次性加载所有块到内存</li>
                <li>内存视图 (<code>memoryview</code>) 实现零拷贝数据切片</li>
            </ul>
            
            <h3>处理速度优化</h3>
            <ul>
                <li>批量操作减少函数调用开销</li>
                <li>快速迭代模式 (<code>iter_blocks_fast</code>) 仅返回索引信息</li>
                <li>使用 <code>range</code> 替代列表推导式减少内存分配</li>
            </ul>
            
            <h3>日志与监控</h3>
            <ul>
                <li>内置高性能日志系统（文件轮转+控制台输出）</li>
                <li>详细记录块处理统计信息</li>
                <li>支持多线程安全处理</li>
            </ul>
        </div>
    </div>

    <footer style="margin-top: 50px; padding-top: 20px; border-top: 1px solid #dee2e6; color: #6c757d; text-align: center;">
        <p>文档生成时间: 2025-10-17 | FirmwareChunker High Performance Edition</p>
    </footer>
</body>
</html>